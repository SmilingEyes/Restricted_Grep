#!/bin/bash

#########################################################
## This script is licensed under the UIUC/NCSA License ##
#########################################################

## Copyright (c) 2015 Kevin Song All rights reserved.

## Developed by: Kevin Song
##               UC Merced

## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation files
## (the "Software"), to deal with the Software without restriction,
## including without limitation the rights to use, copy, modify, merge,
## publish, distribute, sublicense, and/or sell copies of the Software,
## and to permit persons to whom the Software is furnished to do so,
## subject to the following conditions:

##     Redistributions of source code must retain the above copyright
##     notice, this list of conditions and the following disclaimers.
##     Redistributions in binary form must reproduce the above
##     copyright notice, this list of conditions and the following
##     disclaimers in the documentation and/or other materials provided
##     with the distribution.  Neither the names of <Name of
##     Development Group, Name of Institution>, nor the names of its
##     contributors may be used to endorse or promote products derived
##     from this Software without specific prior written permission.

## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
## IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
## IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
## THE SOFTWARE.

#########################################################
################ End License Text #######################
#########################################################

### This section added in 2015 ###

#This script was originally written in Summer 2013 as part of a test suite for
#CSE 031 at UC Merced. The requirements for the program were different back then,
#but this script doesn't work on test cases and correct answers. Instead, it
#compares the outputs of the system version of grep to the student's version
#of grep and compares the two. If the outputs are identical, the program passes
#that particular test case.

#The test cases in this script were intended to be run on a file called 'words.txt',
#which was a dictionary from Dive Into Python, with added gibbersh strings to test
#longer sequences of wildcards, and some strings with punctuation, to test escape
#sequences. If this file is not available, you can always build your own.

#I've gone through and added commenting and extra verbosity where needed to try
#and make this script understandable to those who are less familiar with shell
#programming. If you're still not sure what a particular line does, try plugging
#it into explainshell.com for a quick explanation.

#While the code may seem really long, most of it is boilerplate. If you take out the
#pretty formatting, error messages, and automation, the program is basically two components:
#a function called `test_grep` which takes a given pattern and tests the user's grep with it,
#and a giant list of test patterns.

### End added section ###

#This script assumes that the binary generated by gcc is called "rgrep". If this
#is not the case, please change the GCC_OUTPUT variable.

### EXIT CODE REFERENCE
#Exit 0 Normal
#Exit -1 Cannot acquire words.txt
#Exit -2 Cannot find binary file
#Exit -3 No pattern to -p
#Exit 1 = rgrep failed a test
###


# Assign some configuration variables for use in the program
GCC_OUTPUT="rgrep"           #name of program
BINARY_NAME="./$GCC_OUTPUT"  #command used to execute program
DICTIONARY_NAME="words.txt"  #name of dictionary
DICTIONARY_URL="https://dl.dropboxusercontent.com/u/48143647/test_rgrep/words.txt"
TESTS_FAILED=false
GLOBAL_ARG="$1"              #used in test_grep

# A few things to note:
# - BINARY_NAME is just GCC_OUTPUT with a './' on the front. E.g.
#   if GCC_OUTPUT is "herp", BINARY_NAME is "./herp". Bash will
#   "expand" variable names inside of double quotes, so
#   "$GCC_OUTPUT" is replaced with the value of the variable
#   GCC_OUTPUT before it's assigned to BINARY_NAME
# - Bash does not really understand the idea of a boolean or integer
#   TESTS_FAILED is the string "false", not some boolean variable.
#   That is to say that `if [ $TESTS_FAILED ]` will not produce the
#   result you'd expect if you are a C++ programmer.

#Help message. `$1` is the first argument, analagous to `argv[1]` in C
#To terminate an if-block in bash, use the keyword `fi`
if [ "$1" = "-help" ]; then
printf "
This script runs rgrep on a downloaded dictionary from Swampy and \
compares it to the output of the standard system grep, stopping if \
it finds any mistakes. It will print out a side-by-side output of the \
located mistakes.

To run all the tests even if a mistake is encountered, use the '-all' flag.\
This script will then only print out a line saying what pattern the error was\
encountered on.

If you would like to run your own pattern, pass it to this script after\
the '-p' flag, e.g. ./test_rgrep -p 'spam'

To see this message again, run with '-help'. \n"
exit 0
# https://swampy.googlecode.com/svn-history/r2/trunk/python2/words.txt  Original link
fi

### BEGIN SETUP CODE ###

#The setup code is simply to set up the environment for the script--making sure that
#the dictionaries exist, as well as diff and the rgrep binary.

# We look to see if the dictionary exists. If it does not, we attempt to get it with
# curl. command is a trick to see if curl exists (see: https://tinyurl.com/oczne6g)

if [ ! -f $DICTIONARY_NAME ]; then
	command -v curl >/dev/null 2>&1 &&{
		printf "Acquiring $DICTIONARY_NAME through curl... \n"
		curl -o $DICTIONARY_NAME $DICTIONARY_URL
	}
fi

# If the dictionary still doesn't exist (or if curl didn't work), try to get the
# dictionary with wget. (Note: curl and wget have slightly different syntax)

if [ ! -f $DICTIONARY_NAME ]; then
	command -v wget >/dev/null 2>&1 && {
	printf "Acquiring $DICTIONARY_NAME through wget... \n"
	wget $DICTIONARY_URL -O $DICTIONARY_NAME
	}
fi

#If it still doesn't exist, exit with an error. We need that dictionary for this to work.

if [ ! -f $DICTIONARY_NAME ]; then
	printf "There's no way to acquire the neccesary files! (need wget or curl) \n"
	printf "Please install wget or curl, OR download the file from 
         $DICTIONARY_URL
		 and save it as $DICTIONARY_NAME \n"
	exit -1
fi


if [ ! -f $BINARY_NAME ]; then  #Check for existence of expected binary
	printf "Binary not found! Current target is $BINARY_NAME. 
If this is wrong, please change the name in the '$BINARY_NAME' 
field at the top of the script! \n"
	exit -2
fi

#Check for existence of diff
hash diff 2>/dev/null || {printf "Script requires diff to work! Please install diff. \n"}
hash diff 2>/dev/null || {exit -2}


printf "Preparing to run test cases..."

### END SETUP CODE ###


# Clear the screen to make room for the results
clear; clear;

# test_grep is the heart of this code. It takes a single string pattern and runs system
# grep and rgrep against it, using the dictionary as the source of words. If diff indicates
# that there were no differences, it returns normally. If the two disagree, it prints the
# input pattern, the side-by-side output, and exits (unless the '-all' flag is passed).

test_grep(){

	# Run diff. You might want to look at `man diff` and read about subshells for this...it's
	# a nasty command. Trust me when I say it basically checks to see if rgrep and grep agree.
	diff <(grep $1 -E < $DICTIONARY_NAME) <($BINARY_NAME $1 < $DICTIONARY_NAME) > /dev/null

	#The special variable $? is the return status from the last command (here, diff). If it's not
	#zero, then diff encountered some sort of difference in the two. If that happens...
	if [ $? -ne 0 ]; then

		# If not running all tests, print info and exit. Otherwise, print pattern and keep going.
		if [ "$GLOBAL_ARG" !=  "-all" ]; then
			printf "\n"
			diff <(grep -E $1 < $DICTIONARY_NAME) <($BINARY_NAME $1 < $DICTIONARY_NAME) -y -W 80
			printf "\n\n ===Test failed!=== \n"
			printf "The search pattern was '%s' \n" $1
			printf "Above on the left is what rgrep should have returned,
along with the actual results from rgrep (rgrep on right) \n\n"
			printf "If you would like to force all tests (without stopping for errors),\n"
			printf "use the -all flag. Exiting. \n"
			exit 1
		else
			printf "\nTest failed on pattern '%s'\n" $1
		fi
		TESTS_FAILED=true
	fi
}

#Check to see if the user wants a custom test

if [ "$1" = "-p" ]; then
	if [ -z "$2" ]; then
		printf "No pattern! Usage: ./test_rgrep -p [pattern]\n"
		exit -3
	fi

	# Run test_grep function on user-supplied pattern
	test_grep $2
	
	if ! $TESTS_FAILED; then
		printf "Custom test case [ $2 ] passed!"
		exit 0
	fi
fi

### BEGIN TESTS ###

# From here to the exit messages, it's basically just tests. You can add
# or remove tests as you'd like from here---the tests here were specially designed
# to work with the custom dictionary.

printf "\nStarting tests...\n"

test_grep 'pow'
test_grep 'papere'
test_grep 'headednesses'
test_grep 'aca'
test_grep '.....'

test_grep 'spea?r'
test_grep 'sw?ill'

test_grep '\.'
test_grep '\?'
test_grep '\\'
test_grep '\a'

test_grep '\.\.?.\?'
test_grep '\\\\?'

## Add your test cases here

if $TESTS_FAILED; then

	printf "\nAt least one test did not complete successfully.\n
This could be due to either a failure of rgrep or a glitch
in this script. Please examine the failed case(s) carefully."

else
	printf "\n\n=====================\n"
	printf "You passed all the tests in this script! \n"
	echo '
          /(|
          (  :
         __\  \  _____
       (____)  `|
      (____)|   |
       (____).__|
        (___)__.|_____

        GOOD JOB!!!'

fi


exit 0
